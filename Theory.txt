1. Какой самый эффективный способ конкатенации строк?
Strings.builder - самый эффективный способ конкатенации строк

2. Что такое интерфейсы, как они применяются в Go?
Интерфейсы - "шаблон поведения" для страктов. 
Применяются для стандартизации описания методов страктов, а также для сокращения кода (уменьшения повторяемости)

3. Чем отличаются RWMutex от Mutex?
Mutex даёт доступ к данным только одному потоку и на чтение, и на запись. 
RWmutex позволяет нескольким потокам читать данные одновременно.


4. Чем отличаются буферизированные и не буферизированные каналы?
Не буферизированные каналы не имеют ёмкости для хранения сообщений, буферизированные имеют.


5. Какой размер у структуры struct{}{}?
Минимальный размер 0 байт, обычно 1 байт для обеспечения каждому уникального адреса.


6. Есть ли в Go перегрузка методов или операторов?
Нет.

7. В какой последовательности будут выведены элементы map[int]int?

Пример:
m[0]=1
m[1]=124
m[2]=281

В случайном



8. В чем разница make и new?
make применяется только для мап, слайсов и каналов, и возвращает такой же тип переменной. 
New возвращает указатель на новую переменную


9. Сколько существует способов задать переменную типа slice или map?
Объявить и make по-отдельности
Объявить и make одной строкой
Объявить и инициализировать


10. Что выведет данная программа и почему?


func update(p *int) {
  b := 2
  p = &b
}

func main() {
  var (
     a = 1
     p = &a
  )
  fmt.Println(*p)
  update(p)
  fmt.Println(*p)
}

1
1
Переменная p в ф-ции update - локальная, и на p в main не влияет.

11. Что выведет данная программа и почему?



func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
Программа выпадет в дедлок т.к. вейтгруп передан значением, а не указателем.

12. Что выведет данная программа и почему?


func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
0, потому что происходит shadow declaration


13. Что выведет данная программа и почему?


func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
100 2 3 4 5, т.к. когда мы назначаем нулевому элементу значение 100, v всё ещё указывает на тот же массив. 
После append v будет указывать на другой массив данных 100 2 3 4 5 6.


14. Что выведет данная программа и почему?


func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
[b b a] [a a], т.к. при аппенде внутренний slice будет указывать на другой массив данных [a a a], а внешний на всё тот же [a a]
